# instrumentation-for-php
Ifp 并不像xhprof 一样对PHP 做深入的测量，而是更关注数据库调用。所以当无法在数据库层面进行测量的时候，Ifp 可以很好地帮助应用剖析数据库的利用率。Ifp 是一个提供了计数器和计时器的单例类，很容易部署到生产环境中，因为不需要访问PHP 配置的权限（对很多开发人员来说，都没有访问PHP配置的权限，所以这一点很重要）。  　　Ifp 不会自动剖析所有的PHP 函数，而只是针对重要的函数。例如，对于某些需要剖析的地方要用到自定义的计数器，就需要手工启动和停止。但Ifp 可以自动对整个页面的执行进行计时，这样对自动测量数据库和memcached 的调用就比较简单，对于这种情况就无须手工启动或者停止。这也意味着，Ifp 可以剖析三种情况：应用程序的请求（如page view）、数据库的查询和缓存的查询。Ifp 还可以将计数器和计时器输出到Apache,通过Apache 可以将结果写入到日志中。这是一种方便且轻量的记录结果的方式。Ifp 不会保存其他数据，所以也不需要有系统管理员的权限。  　　使用Ifp,只需要简单地在页面的开始处调用start_request（）。理想情况下，在程序的一开始就应当调用：  　　require_once（'Instrumentation.php'）；  　　Instrumentation::get_instance（）->start_request（）；  　　这段代码注册了一个shutdown函数，所以在执行结束的地方不需要再做更多的处理。  　　IFP会自动对SQL添加注释，便于从数据库的查询日志中更灵活地分析应用的情况，通过SHOW PROCESSLIST也可以更清楚地知道性能低的查询出自何处。大多数情况下，定位性能低下查询的来源都不容易，尤其是那些通过字符串拼接出来的查询语句，都没有办法在源代码中去搜索。那么IFP的这个功能就可以帮助解决这个问题，它可以很快定位到查询是从何处而来的，即时应用和数据库中间加了代理或者负载均衡层，也可以确认是哪个应用的用户，是哪个页面请求，是源代码中的哪个函数，代码行号，甚至是所创建的计数器的键值对。下面是一个例子：  　　-- File: index.php Line: 118 Function: fullCachePage request_id: ABC session_id: XYZ  　　SELECT * FROM …  　　如何测量MySQL 的调用取决于连接MySQL 的接口。如果使用的是面向对象的mysqli接口，则只需要修改一行代码：将构造函数从mysqli 改为可以自动测量的mysqli_x 即可。mysqli_x 构造函数是由Ifp 提供的子类，可以在后台测量并改写查询。如果使用的不是面向对象的接口，或者是其他的数据库访问层，则需要修改更多的代码。如果数据库调用不是分散在代码各处还好，否则建议使用集成开发环境（IDE）如Eclipse,这样修改起来要容易些。但不管从哪个方面来看，将访问数据库的代码集中到一起都可以说是最佳实践。  　　Ifp 的结果很容易分析。Percona Toolkit 中的pt-query-digest 能够很方便地从查询注释中抽取出键值对，所以只需要简单的将查询记录到MySQL 的日志文件中，再对日志文件进行处理即可。Apache 的mod_log_config 模块可以利用Ifp 输出的环境变量来定制日志输出，其中的宏%D 还可以以微秒级记录请求时间。  　　也可以通过LOAD DATA INFILE 将Apache 的日志载入到MySQL 数据库中，然后通过SQL 进行查询。在Ifp 的网站上有一个PDF 的幻灯片，详细给出了使用示例，包括查询和命令行参数都有。  　　或许你会说不想或者没时间在代码中加入测量的功能，其实这事比想象的要容易得多，而且花在优化上的时间将会由于性能的优化而加倍地回报给你。对应用的测量是不可替代的。当然最好是直接使用New Relic、xhprof、Ifp 或者其他已有的优化工具，而不必重新去发明"轮子".
